<html>
<head>
  <link rel="stylesheet" href="./dist/talkie.min.css">
  <link rel="stylesheet" href="./dist/talkie-default.min.css">
  <link rel="stylesheet" href="./style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/monokai_sublime.min.css">
</head>
<body>

<script layout type="text/x-markdown">
## 7章
### HTTP/2のシンタックス:
### プロトコルの再定義
</script>

<script layout type="text/x-markdown">
#### 本章で学ぶこと
* HTTP/2や、その前後に策定された新しい世代の様々なプロトコルについて紹介する
</script>

<script layout type="text/x-markdown">
### 7.1 HTTP/2
</script>

<script layout type="text/x-markdown">
### 大きく異なったデータ表現になった
* ストリーム(1.1のパイプラインに近いもの)を使って、バイナリデータを多重に送受信する仕組みに変更
* ストリーム内での優先順位設定や、サーバーサイドからデータ通信を行うサーバーサイドプッシュを実装
* ヘッダーが圧縮されるようになった
* -> HTTP/2の目的は、**通信の高速化**
</script>

<script layout type="text/x-markdown">
### 7.1.1 ストリームによる通信の高速化
</script>

<script layout type="text/x-markdown">
* バイナリベースのプロトコルになった
* 各データは `フレーム` と呼ばれる単位で送受信が行われる
* 1本のTCP接続の内部にストリームという仮想のTCPソケットを作って通信を行う
* < TCPと比べての利点 >
* ・ ID (Stream Identifier)とTCPの通信容量が許す限り、数万接続でも並列化できる
* ・ 最初からLISTENと同じ状態(IDLE状態)であり、ヘッダーを受け取ると通信可能なOPEN状態になるため、通信が出来るまでのステップが少ない
</script>

<script layout type="text/x-markdown">
* 各フレームには9バイトの共通ヘッダーがある
* < Stream Identifierの特徴 >
* ・ 同じストリームから受信したデータであることを識別するためのid
* ・ 奇数はクライアント->サーバー・偶数はサーバー->クライアントの通信に使う。ただし、0は予約されているので使うとエラーになる。
</script>

<script layout type="text/x-markdown">
### 7.1.2 HTTP/2のアプリケーション層
</script>

<script layout type="text/x-markdown">
* ヘッダーでは、最初にフレームサイズが入っているので、受信側のTCPソケットのバッファをすばやく空にでき、次のデータを高速にリクエストできる
* ボディでは、フレーム同士が独立しているので、途中で他のフレームが挟まっても問題ない (重いレスポンスがあっても、他の通信が行える)
</script>

<script layout type="text/x-markdown">
### 7.1.3 フローコントロール
</script>

<script layout type="text/x-markdown">
* HTTP/2はアプリケーション層に当たるが、トランスポート層に近いものを内部に持っている (e.g. フローコントロール)
* TCPソケット : HTTP/2のストリーム ≒ OSスレッド : グリーンスレッド
</script>

<script layout type="text/x-markdown">
### 7.1.4 サーバープッシュ
</script>

<script layout type="text/x-markdown">
* 優先度の高いコンテンツをクライアントからリクエストされる前に送信する仕組み
* WebSocketなどの双方向通信と異なり、Webページを構成するファイルのDL用に使う
* 処理の詳細
* ・ クライアントはリクエストするまで、サーバー母らプッシュされていることを検知できない
* ・ プッシュされたコンテンツは事前にキャッシュに入る
* ・ キャッシュ後にクライアントがリクエストをすると、遅延なくDLできたように見える
</script>

<script layout type="text/x-markdown">
### 7.1.5 HPACKによるヘッダーの圧縮
</script>

<script layout type="text/x-markdown">
* HPACKは、ヘッダーの圧縮方式
* 一般的な圧縮アルゴリズムと異なり、事前に辞書を持っている (決まった名前や結果が多いため、外部辞書に入れておくことで、圧縮後のサイズを小さくしている)
* HTTP/2では静的テーブルという名前で、事前に頻出するヘッダー名とヘッダー値の組をテーブルに持っている
* さらに、同じコネクション中に登場したへダーはインデックス化して動的テーブルに加えることで、再登場した時はインデックス値だけで表現でき、小サイズかを実現している
</script>

<script layout type="text/x-markdown">
### 7.1.6 SPDYとQUIC
</script>

<script layout type="text/x-markdown">
* SPDYは、Googleが開発したHTTP代替プロトコルで、HTTP/2の原型になったもの
* 開発の動機は転送速度の向上 (並列アクセスでのブロッキングが減るため、小さなファイルをたくさん転送する場合に高速化が期待できる)
* TCPソケット上のアプリケーション層に実装された
</script>

<script layout type="text/x-markdown">
* QUICは、UDPソケット上に用意されたプロトコル。Googleが開発している
* 開発の動機はSPDYよりさらなる高速化 (TCPのハンドシェイクなどのコストを削減する)
* また、HTTP/2と協調動作することで、TCPとHTTP/2の重複処理を簡略化する (フローコントロールなど)
* すでにChromeでは組み込まれており、Googleのサービスの半分のリクエストがQUICで行われている
</script>

<script layout type="text/x-markdown">
* [GoogleのQUICプロトコル：TCPからUDPへWebを移行する | POSTD](https://postd.cc/googles-quic-protocol-moving-web-tcp-udp/)
</script>

<script layout type="text/x-markdown">
### 7.2 Fetch API
</script>

<script layout type="text/x-markdown">
* JSで利用する、XMLHTTPRequestと同様の、サーバーアクセスを行う関数
* ・ XHRよりもCORSの取り扱いが制御しやすい
* ・ Promiseに準拠しているので、非同期処理が記述しやすい
* ・ キャッシュを制御できる
* ・ リダイレクトを制御できる
* ・ リファラーポリシーを設定できる
* ・ Service Worker内から利用できる
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
<script src="./dist/talkie.min.js"></script>
<script>Talkie();</script>
</body>
</html>
