<html>
<head>
  <link rel="stylesheet" href="./dist/talkie.min.css">
  <link rel="stylesheet" href="./dist/talkie-default.min.css">
  <link rel="stylesheet" href="./style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/monokai_sublime.min.css">
</head>
<body>

<script layout type="text/x-markdown">
## 7章
### HTTP/2のシンタックス:
### プロトコルの再定義
</script>

<script layout type="text/x-markdown">
#### 本章で学ぶこと
* HTTP/2や、その前後に策定された新しい世代の様々なプロトコルについて紹介する
</script>

<script layout type="text/x-markdown">
### 7.1 HTTP/2
</script>

<script layout type="text/x-markdown">
### 大きく異なったデータ表現になった
* ストリーム(1.1のパイプラインに近いもの)を使って、バイナリデータを多重に送受信する仕組みに変更
* ストリーム内での優先順位設定や、サーバーサイドからデータ通信を行うサーバーサイドプッシュを実装
* ヘッダーが圧縮されるようになった
* -> HTTP/2の目的は、**通信の高速化**
</script>

<script layout type="text/x-markdown">
### 7.1.1 ストリームによる通信の高速化
</script>

<script layout type="text/x-markdown">
* バイナリベースのプロトコルになった
* 各データは `フレーム` と呼ばれる単位で送受信が行われる
* 1本のTCP接続の内部にストリームという仮想のTCPソケットを作って通信を行う
* < TCPと比べての利点 >
* ・ ID (Stream Identifier)とTCPの通信容量が許す限り、数万接続でも並列化できる
* ・ 最初からLISTENと同じ状態(IDLE状態)であり、ヘッダーを受け取ると通信可能なOPEN状態になるため、通信が出来るまでのステップが少ない
</script>

<script layout type="text/x-markdown">
* 各フレームには9バイトの共通ヘッダーがある
* < Stream Identifierの特徴 >
* ・ 同じストリームから受信したデータであることを識別するためのid
* ・ 奇数はクライアント->サーバー・偶数はサーバー->クライアントの通信に使う。ただし、0は予約されているので使うとエラーになる。
</script>

<script layout type="text/x-markdown">
### 7.1.2 HTTP/2のアプリケーション層
</script>

<script layout type="text/x-markdown">
* ヘッダーでは、最初にフレームサイズが入っているので、受信側のTCPソケットのバッファをすばやく空にでき、次のデータを高速にリクエストできる
* ボディでは、フレーム同士が独立しているので、途中で他のフレームが挟まっても問題ない (重いレスポンスがあっても、他の通信が行える)
</script>

<script layout type="text/x-markdown">
### 7.1.3 フローコントロール
</script>

<script layout type="text/x-markdown">
* HTTP/2はアプリケーション層に当たるが、トランスポート層に近いものを内部に持っている (e.g. フローコントロール)
* TCPソケット : HTTP/2のストリーム ≒ OSスレッド : グリーンスレッド
</script>

<script layout type="text/x-markdown">
### 7.1.4 サーバープッシュ
</script>

<script layout type="text/x-markdown">
* 優先度の高いコンテンツをクライアントからリクエストされる前に送信する仕組み
* WebSocketなどの双方向通信と異なり、Webページを構成するファイルのDL用に使う
* 処理の詳細
* ・ クライアントはリクエストするまで、サーバーからプッシュされていることを検知できない
* ・ プッシュされたコンテンツは事前にキャッシュに入る
* ・ キャッシュ後にクライアントがリクエストをすると、遅延なくDLできたように見える
</script>

<script layout type="text/x-markdown">
### 7.1.5 HPACKによるヘッダーの圧縮
</script>

<script layout type="text/x-markdown">
* HPACKは、ヘッダーの圧縮方式
* 一般的な圧縮アルゴリズムと異なり、事前に辞書を持っている (決まった名前や結果が多いため、外部辞書に入れておくことで、圧縮後のサイズを小さくしている)
* HTTP/2では静的テーブルという名前で、事前に頻出するヘッダー名とヘッダー値の組をテーブルに持っている
* さらに、同じコネクション中に登場したへダーはインデックス化して動的テーブルに加えることで、再登場した時はインデックス値だけで表現でき、小サイズかを実現している
</script>

<script layout type="text/x-markdown">
### 7.1.6 SPDYとQUIC
</script>

<script layout type="text/x-markdown">
* SPDYは、Googleが開発したHTTP代替プロトコルで、HTTP/2の原型になったもの
* 開発の動機は転送速度の向上 (並列アクセスでのブロッキングが減るため、小さなファイルをたくさん転送する場合に高速化が期待できる)
* TCPソケット上のアプリケーション層に実装された
</script>

<script layout type="text/x-markdown">
* QUICは、UDPソケット上に用意されたプロトコル。Googleが開発している
* 開発の動機はSPDYよりさらなる高速化 (TCPのハンドシェイクなどのコストを削減する)
* また、HTTP/2と協調動作することで、TCPとHTTP/2の重複処理を簡略化する (フローコントロールなど)
* すでにChromeでは組み込まれており、Googleのサービスの半分のリクエストがQUICで行われている
</script>

<script layout type="text/x-markdown">
* [GoogleのQUICプロトコル：TCPからUDPへWebを移行する | POSTD](https://postd.cc/googles-quic-protocol-moving-web-tcp-udp/)
</script>

<script layout type="text/x-markdown">
### 7.2 Fetch API
</script>

<script layout type="text/x-markdown">
* JSで利用する、XMLHTTPRequestと同様の、サーバーアクセスを行う関数
* ・ XHRよりもCORSの取り扱いが制御しやすい
* ・ Promiseに準拠しているので、非同期処理が記述しやすい
* ・ キャッシュを制御できる
* ・ リダイレクトを制御できる
* ・ リファラーポリシーを設定できる
* ・ Service Worker内から利用できる
</script>

<script layout type="text/x-markdown">
### 7.2.1 Fetch APIの基本
</script>

<script layout type="text/x-markdown">
* 処理の基本要素
* 1 fetch()関数を呼び出す (XHRのようにオブジェクトは作らない)
* 2 fetch()関数の第2引数は、オプションのオブジェクト (省略可能)
* 3 .then()関数に、レスポンスが返ってきた後に呼び出されるコールバックを渡す (Promise)
* 4 .then()に渡すコールバックがさらにPromiseを返す時は、.then()をつなげる (Promiseのメソッドチェーン)
</script>

<script layout type="text/x-markdown">
* FetchAPIの最初の.then()の挙動
* ・ レスポンスヘッダー付近まで読み終わったタイミングで呼び出される (ボディをどの形式で取得するかを決定するため)
* ・ その後、サーバーからの読み込みを行うために再び.then()を呼び出してDLが完了するのを待つ
* FetchAPIでは、オプションのデフォルトはセキュリティの厳しい設定が選択されているので、必要に応じて明確に解除する必要がある (セキュリティ向上を重視した設計)
</script>

<script layout type="text/x-markdown">
* Promiseについては、 [JavaScript Promiseの本](http://azu.github.io/promises-book/)がわかりやすい
</script>

<script layout type="text/x-markdown">
### 7.2.2 Fetch APIにしかできないこと
</script>

<script layout type="text/x-markdown">
* ・ キャッシュの制御
* ・ リダイレクトの制御
* ・ Service Worker対応
</script>

<script layout type="text/x-markdown">
* Service Workerとは、ブラウザがWebページとは別にバックグラウンドで実行するスクリプトのこと
* ブラウザ(JS)とサーバーの間で動く中間レイヤーとして使われる
* (e.g.) PWAの一環として、アプリケーションのライフサイクルや通信内容をコントロールできるようにする (オフラインでの動作を可能にしたり、通知を扱えるようにできる)
</script>

<script layout type="text/x-markdown">
### 7.3 Server-Sent Events
</script>

<script layout type="text/x-markdown">
* HTML5の機能のひとつ
* CometのロングポーリングとChunkedレスポンスの組み合わせで、クライアントの1度のリクエストに対して、サーバーから複数のイベント送信を実現している
* HTTP/1.1のChunked形式を使っているが、HTTPの上に`イベントストリーム`と呼ばれる別のテキストプロトコルを乗せている。MIMEタイプは`text/event-stream`
</script>

<script layout type="text/x-markdown">
### イベントストリームの説明 (text/event-stream)
</script>

<script layout type="text/x-markdown">
* テキストエンコーディングは、UTF-8
* 4種類のタグがあり、`タグ: value`の形で表現し、空白行でデータが区切られる
* valueはテキストであればなんでもよい (BASE64エンコードすれば、バイナリも扱える)
</script>

<script layout type="text/x-markdown">
### イベントストリームの説明 (JS)
</script>

<script layout type="text/x-markdown">
* EventSourceクラスを使って、Server-Sent Eventsにアクセスする
* -> このクラスは、イベントストリームのパースや、接続が切れた時の再接続を行ってくれる
</script>

<script layout type="text/x-markdown">
### 7.4 WebSocket
</script>

<script layout type="text/x-markdown">
* クライアント/サーバー間で、オーバーヘッドの小さい双方向通信を実現するプロトコル
* フレーム単位で送受信を行うが、通信相手が決まっているため、通信先の情報などは持たない (HTTPのボディのみを送信しているようなもの)
* 通信がスタートしたら双方から自由にデータを送受信できる
</script>

<script layout type="text/x-markdown">
### 7.4.1 WebSocketはステートフル
</script>

<script layout type="text/x-markdown">
* WebSocketはメモリ上にデータを持った状態で通信するケースが多い
* (e.g.) チャットなら、ルームのような単位でコネクションを管理する
* -> 再接続する場合には同じサーバーに繋ぐ必要があるため、WebSocket対応のLBを使うか、LBを使わないなどの対応が必要になる
</script>

<script layout type="text/x-markdown">
### 7.4.2 JavaScriptのクライアントAPI
</script>

<script layout type="text/x-markdown">
* WebSocketはTCPソケットに近い機能を提供するAPIなので、JSのAPIも近い形態になってる
* 通信はサーバーが受診を待ち受けている状態で、必ずクライアントから接続する
* JSで接続を確立するには、次の2つのことをする
* 1 WebSocketクラスのコンストラクタに接続先のURLを指定する
* 2 send()メソッドでデータを送信する
* 送受信に使えるデータは、文字列・Blob・ArrayBufferなど
</script>

<script layout type="text/x-markdown">
* 接続後に、クライアントが行う操作は次の3つ
* ・ `send([データ])`: データを送信
* ・ `onmessage`: サーバーから送られてきたデータを受信
* ・ `close([コード [, 理由]])`: ソケットを切断
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 7.
</script>

<script layout type="text/x-markdown">
*
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
<script src="./dist/talkie.min.js"></script>
<script>Talkie();</script>
</body>
</html>
