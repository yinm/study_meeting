<html>
<head>
  <link rel="stylesheet" href="./dist/talkie.min.css">
  <link rel="stylesheet" href="./dist/talkie-default.min.css">
  <link rel="stylesheet" href="./style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/monokai_sublime.min.css">
</head>
<body>

<script layout type="text/x-markdown">
## 5章
### HTTP/1.1のセマンティクス:
### 広がるHTTPの用途
</script>

<script layout type="text/x-markdown">
* HTTP/1.1以降で拡張されたプロトコルや規約を使った事例を紹介
*  ▶ ファイルのダウンロード (ファイル名指定)
*  ▶ ダウンロードの中断・再開 (範囲アクセス)
*  ▶ XMLHttpRequest
*  ▶ Geo-Location
*  ▶ X-Powered-By
*  ▶ リモートプロシージャコール
*  ▶ WebDAV
*  ▶ Webサイト間で共通の認証・認可プラットフォーム
</script>

<script layout type="text/x-markdown">
### 5.1 ファイルをダウンロードした後でローカルに保存
</script>

<script layout type="text/x-markdown">
* `Content-Disposition: attachment; filename=ファイル名`のようなヘッダーがあると、ファイル保存ダイアログが表示される
* ・ ファイル名のデフォルトを日本語にする場合は、`*=utf-8'' 日本語ファイル名`を加える
* `Content-Disposition`ヘッダーも電子メールのRFCから移植された
* ダウンロード完了ページは、`<meta http-equiv="refresh" content="o;URL=./download_file">` を使って実現している
</script>

<script layout type="text/x-markdown">
### 5.2 ダウンロードの中断、再開
</script>

<script layout type="text/x-markdown">
* 通信回線が不安定な場合などのために、ダウンロードを中断・再開できる機能が用意されている
* サーバーが範囲指定ダウンロードに対応している場合は、`Accept-Ranges`ヘッダーを返す
* ・ `Accept-Ranges: bytes`: 範囲指定ダウンロードを、バイト単位で受け入れる
* ・ `Accept-Ranges: none`: 範囲指定ダウンロードを受け入れない
* また、ダウンロードしたいファイルのEtagヘッダーを受け取って、変更を検知する必要がある
  * ・ダウンロードの途中でファイル内容が変更されてしまうと、ダウンロードしたファイル片の価値がなくなるため
</script>

<script layout type="text/x-markdown">
* リクエストを送る時は、欲しい範囲を`Range`ヘッダーに付与する
* レスポンスのステータスコードは、以下の2種類がある
* ・ダウンロードできる場合は、 `206 Partial Content`
* ・クライアントからの範囲指定が無効の場合は、`416 Range Not Satisfiable`
</script>

<script layout type="text/x-markdown">
### 5.2.1 複数範囲のダウンロード
</script>

<script layout type="text/x-markdown">
* `Ranges`ヘッダーを使って、複数範囲指定が可能
* レスポンスには、`Content-Type: multipart/byterangtes`が返ってくる
</script>

<script layout type="text/x-markdown">
### 5.2.2 並列ダウンロード
</script>

<script layout type="text/x-markdown">
* Rangeヘッダーを用いたHTTPアクセスを複数行うことで、ダウンロード速度をあげる手法
* ただし、サーバーに負荷がかかるため、あまり推奨されていない
</script>

<script layout type="text/x-markdown">
### 5.3 XMLHttpRequest
</script>

<script layout type="text/x-markdown">
* XMLHttpRequest(XHR)は、curl相当の機能をJSから実現するもの
* ・ `open()`メソッドで、送信先を指定する。非同期処理をするため、第3引数は基本的にtrueにする
* ・ `send()`メソッドで、送信を開始する
* ・ `onload`イベントで、レスポンスが返ってきた後の処理を指定する
</script>

<script layout="code" invert type="text/x-markdown">
* GETする場合 (`curl -H "MyHeader=HeaderValue" /json`に相当)

```js
const xhr = new XMLHttpRequest();
xhr.open('GET', '/json', true);
xhr.onload = () => {
  // レスポンスが返ってきた時に呼ばれるメソッド
  if (xhr.status === 200) {
    // JSON parseして表示
    console.log(JSON.parse(xhr.responseText));
  }
};
xhr.setRequestHeader('MyHeader', 'HeaderValue');
xhr.send();
```
</script>

<script layout="code" invert type="text/x-markdown">
* POSTする場合 (`curl -d '{"message": "hello world"}' /json`に相当)

```js
const xhr = new XMLHttpRequest();
xhr.open('POST', '/json', true);
xhr.onload = () => {
  // レスポンスが返ってきた時に呼ばれるメソッド
};
xhr.send(JSON.stringify({"message": "hello world"}));
```
</script>

<script layout type="text/x-markdown">
### 5.3.1 XMLHttpRequestとブラウザのHTTPリクエストの違い
</script>

<script layout type="text/x-markdown">
* XHRでは以下の違いがある
* ・ 送信時にHTMLの画面がフラッシュ(リロード)されない
* ・ メソッドとして、GETとPOST以外も送信できる
* ・ プレーンテキスト, JSON, バイナリデータ, XMLなど、様々なフォーマットを送受信できる (responseType)
* ・ セキュリティのための制約がある
</script>

<script layout type="text/x-markdown">
* responseTypeを設定しない場合、以下のレスポンスタイプになる
* ・ XMLのMIMEタイプ(`text/html`, `application/xml`)であれば、`responseXML`
* ・ それ以外は、`responseText`
* MIMEタイプを設定していない場合は、クライアントから指定できる
* ・ `xhr.overrideMimeType('text/html');`
* IEでは、`responseType = json`が使えない
</script>

<script layout="code" invert type="text/x-markdown">
* 例) レスポンスのフォーマットを、画像(バイナリデータ)にする

```js
const xhr = new XMLHttpRequest();
// open処理は省略
xhr.reponseType = 'blob';
xhr.onload = (e) => {
  if (this.status === 200) {
    const blob = this.response;
    const img = document.createElement('img');
    img.onload = (e) => {
      window.URL.revokeObjectURL(img.src);
    };
    img.src = window.URL.createObjectURL(blob);
    document.body.appendChild(img);
  }
};
xhr.send();
```
</script>

<script layout="code" invert type="text/x-markdown">
* 例) IEで、responseTypeがJSONの場合を対応する

```js
const xhr = new XMLHttpRequest();
// open処理は省略
xhr.onload = (e) => {
  if (this.status === 200) {
    const json = JSON.parse(xhr.responseText);
    console.log(json);
  }
};
xhr.send();
```
</script>

<script layout type="text/x-markdown">
### 5.3.2 Comet
</script>

<script layout type="text/x-markdown">
* 双方向通信を行うテクニック(ロングポーリング)のこと
* 双方向通信を行う別のテクニックとして、ポーリングもある
* どちらもレガシーな仕組みを応用したもので、性能が高くなり代わりに多くの環境で使える
* 現在は、ServerSent Eventというチャンク形式を利用した仕組みを使う方が良い (7章で紹介)
</script>

<script layout type="text/x-markdown">
* ポーリングとは、クライアント(通知を受ける側)が頻繁に通知がないか聞きに行く方式
* 何度もリクエストが発生するため、送受信ともに帯域・CPUを消費する
</script>

<script layout type="text/x-markdown">
* Comet(ロングポーリング)とは、通知を確認するリクエストを送信した後、サーバーでレスポンスを保留にしたままにする
* そして、サーバーで通知があった時に、リクエストに見せかけてレスポンスを返す
* このことから、リバースAjaxとも呼ばれる
* ただし、欠点もある
* ・ 後発の方式に比べて、1メッセージあたりのオーバーヘッドが大きめ (大量のヘッダを付与するため)
* ・ 連続したメッセージ送信が苦手 (サーバーからメッセージを送信した後は、再びセッションを張る必要があるため)
</script>

<script layout type="text/x-markdown">
### 5.3.3 XMLHttpRequestのセキュリティ
</script>

<script layout type="text/x-markdown">
* XHRのセキュリティ制御は2つある
* ・ アクセスできる情報の制限
* ・ 送信制限
</script>

<script layout type="text/x-markdown">
* アクセスできる情報の制限として、クッキーの制限がある
* XSSで、ログインセッションのクッキーを外部サイトに流出させられるリスク
* -> `httpOnly`属性をクッキーに付与することで、外部に漏れるリスクが減らせる
</script>

<script layout type="text/x-markdown">
* 通信制限には、ドメイン・メソッド・ヘッダーの3種類がある
* ・ 同一生成元ポリシー(Same Origin Policy)による、リクエストを送信できるドメインの制限
* -> 他のサイトにアクセスしたい場合は、CORSを利用する
* ・ CONNECT, TRACE, TRACKメソッドを使用すると、SecurityError例外が発生する
* ・ プロトコルに影響を与えるものや、ブラウザの能力を超えているものなどをヘッダーに利用できない
* -> ブラウザの能力を超えているものとは、ブラウザが対応していない圧縮形式などのこと
</script>

<script layout type="text/x-markdown">
### 5.4 Geo-Location
</script>

<script layout type="text/x-markdown">
* クライアントの物理的な場所を測定する方法は2つある
* ・ クライアント自身が計測してサービスに送る方法
* ・ サーバー側で推測する方法
</script>

<script layout type="text/x-markdown">
### 5.4.1 クライアント自身が場所を得る方法
</script>

<script layout type="text/x-markdown">
* モダンブラウザは、Geolocation APIを用意している
* ・ スマホなら、GPSや基地局の情報によって、位置を返すことができる
* ・ GPSのついていないPPCでも、wifiなどによる位置測定によって大まかな位置を返すことができる
* 位置情報はプライバシーであるため、使用するにはユーザーの許可が必要になる
</script>

<script layout type="text/x-markdown">
### 5.4.2 サーバーがクライアントの場所を推測する方法
</script>

<script layout type="text/x-markdown">
* GeoIPという、IPアドレスから推測する方法
* レジストりによってIPアドレスが、どのプロバイダなどに割り当てられているかは管理しているが、正確な位置まではわからない
* そのため、Gelocationと同様に、地道に集めたデータを元に位置情報を返している
* ユーザーの許可なしに位置情報が使えるというメリットがある
* ・Amazon.comにアクセスすると、日本のAmazonへ誘導するバナーが表示されるなど
</script>

<script layout type="text/x-markdown">
### 5.5 X-Powered-Byヘッダー
</script>

<script layout type="text/x-markdown">
* 多くのサーバーがシステム名を返すのに使用していた、独自ヘッダー
* セキュリティホールを突かれるリスクが上がるので、使用しない方がいい
* FireFoxは、X-Powered-Byヘッダーを使ってクライアントの挙動を変えていたが、現在は標準化されたヘッダーである、Serverヘッダーを使っている
</script>

<script layout type="text/x-markdown">
### 5.6 リモートプロシージャコール(RPC)
</script>

<script layout type="text/x-markdown">
* 別のコンピュータにある機能を、あたかも自分のコンピュータないであるかのように呼び出して、必要に応じて返り血を受け取る仕組み
* RMI(Remote Method Invocation)とも呼ばれる
* インターネットの広まりとともに、HTTPをベースにするRPCが何種類か誕生した
</script>

<script layout type="text/x-markdown">
### 5.6.1 XML-RPC
</script>

<script layout type="text/x-markdown">
* 最初に規格化されたRPC
* 仕様としては以下ものがある
* ・ Content-Lengthを明示する必要がある (チャンク形式はサポートしていない)
* ・ メソッドは、POSTを使う (GETはキャッシュが残る可能性があるので使用しない)
* ・ `Content-Type: text/xml`を使用する (引数・返り値ともにXMLであるため)
* ・ 多少のエラーがあっても`200 OK`を返す
</script>

<script layout type="text/x-markdown">
### 5.6.2 SOAP
</script>

<script layout type="text/x-markdown">
* XML-RPCを拡張して作られた規格
* サービス指向アーキテクチャで大きな役割を果たしていた
* HTTPの中にミニHTTPを持つような構造になっており、SMTPなどでもメッセージをやりとりできる
* XML-RPCに比べて複雑である上、WSDLを手書きするなどの手間が大きい
</script>

<script layout type="text/x-markdown">
### 5.6.3 JSON-RPC
</script>

<script layout type="text/x-markdown">
* XML-RPCのXMLの代わりに、JSONを使ったRPC
* SOAPに比べて、シンプルにという方針が押し出されている
* 仕様としては以下ものがある
* ・ リクエスト時に必要なものは、`Content-Type`, `Content-Length`, `Accept`
* ・ メソッドにはPOSTを使うが、べき等で安全な処理ならGETも使える
* ・ バージョン指定のため、`"jsonrpc": "2.0"`が必要
* ・ リクエストとレスポンスを対応付けるためにidが必要
</script>

<script layout type="text/x-markdown">
### 5.7 WebDAV
</script>

<script layout type="text/x-markdown">
* HTTPを拡張することで分散システムとして使えるようにしたもの
* Finderなどのファイルマネージャに簡単に接続できる
* ファイルシステムとして使いやすいように、メソッドが追加されている (e.g. MOVE)
</script>

<script layout type="text/x-markdown">
* WebDAVの用語を整理する
* ・ リソース: ファイルに相当する。HTTPの用語を引き継いで、リソースと呼んでいる
* ・ コレクション: ディレクトリに相当する
* ・ プロパティ: リソースやコレクションの属性 (e.g. 作成日時)
* ・ ロック: 先に宣言した人以外の変更を拒絶する仕組み (複数人の編集を制御する)
</script>

<script layout type="text/x-markdown">
### 5.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 5.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 5.
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
### 5.
</script>

<script layout type="text/x-markdown">
*
</script>


<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
<script src="./dist/talkie.min.js"></script>
<script>Talkie();</script>
</body>
</html>
