<html>
<head>
  <link rel="stylesheet" href="./dist/talkie.min.css">
  <link rel="stylesheet" href="./dist/talkie-default.min.css">
  <link rel="stylesheet" href="./style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/monokai_sublime.min.css">
</head>
<body>

<script layout type="text/x-markdown">
## 4章
### HTTP/1.1のシンタックス:
### 高速化と安全性を求めた拡張
</script>

<script layout type="text/x-markdown">
* 本章では、HTTP1.1以降の新しい機能について説明する
* ・通信の高速化
* ・TLSによる暗号化通信のサポート
* ・新メソッドの追加
* ・プロトコルのアップグレード
* ・名前を使ったバーチャルホストのサポート
* ・チャンク転送エンコーディングのサポート
</script>

<script layout type="text/x-markdown">
* HTTP/2 でも、HTTP/1.1で策定されている内容が現役で使われている
* ・通信内容
* ・ブラウザとサーバーのコミュニケーションのセマンティクス
</script>

<script layout type="text/x-markdown">
### 4.1 通信の高速化
</script>

<script layout type="text/x-markdown">
* Keep-Aliveとパイプライニングは、<br>すべてのHTTP通信を高速化する機能
* cf) EtagとCache-Controlは、<br>リソースごとに通信を最適化する機能
</script>

<script layout type="text/x-markdown">
### 4.1.1 Keep-Alive
</script>

<script layout type="text/x-markdown">
* TCP/IPの通信を効率化する仕組み <br>(連続したリクエストの時に、接続を再利用する)
* 利用するには、<br>`Connection: Keep-Alive` をヘッダーをリクエストに付与する
* TLS通信の場合に、特にメリットがある (RTTを減らせるため)
</script>

<script layout type="text/x-markdown">
* Keep-Aliveの終了方法には、2種類ある
* ・`Connection: Close` <br>ヘッダーを追加する (リクエスト or レスポンス)
* ・タイムアウトする <br>(クライアント or サーバーの持続時間の短い方を採用)
* 通信が継続している間は、OSのリソースを消費しているため、短い時間で接続を切るのにも意味がある
</script>

<script layout type="text/x-markdown">
### 4.1.2 パイプライニング
</script>

<script layout type="text/x-markdown">
* リクエストが完了する前に次のリクエストを送信し、ネットワークの稼働率を上げる機能
* Keep-Aliveの利用を前提としている
* 仕様上は、サーバーはリクエストが来た順でレスポンスを返す
* しかし、パフォーマンスがあまり上がらないという話もある
* ・HOL Blockingが発生する
* ・サーバーやプロキシの影響でうまく動作しない
* **-> デフォルトで使っているブラウザはあまりない**
</script>

<script layout type="text/x-markdown">
* HTTP/2で、ストリームという新しい仕組みとして生まれ変わった
* ・HTTP/2では、HTTPS通信が前提になりつつあるので、プロキシの影響を受けない
* ・HTTP/2では、リクエスト順にレスポンスを返す必要がなくなった
* -> 詳細は、7章で解説
</script>

<script layout type="text/x-markdown">
### 4.2 TLS (トランスポート・レイヤー・セキュリティ)
</script>

<script layout type="text/x-markdown">
* 通信経路を暗号化する技術 (SSL3.0を元に作成された)
* TLSの暗号化自体は、様々な形式のデータを双方向に流すことができる (HTTPに依存していない)
* HTTP/1.1以前とは前方互換性のない仕組みを導入するインフラになっている
* e.g.) WebSocket, HTTP/2
* SSLは、RFCで非推奨になっている (= TLSが主流である)
* ただし、TLSに関連するものの名称に、「SSL」の文字が入っていることがある
* e.g.) OpenSSL, EV SSL
</script>

<script layout type="text/x-markdown">
### 4.2.1 ハッシュ関数
</script>

<script layout type="text/x-markdown">
* 入力データから、ルールに従ってデータを集約することで、短いデータ(ハッシュ値)を作り出す
* ハッシュの意味は、「細切れ」
</script>

<script layout type="text/x-markdown">
#### 暗号化通信を行う上で便利な、4つの数学的特性がある
* ・同じアルゴリズムと同じ入力データなら、結果として作られるハッシュ値は同じ
* ・アルゴリズムが同じなら、ハッシュ値は同じ長さになる
* ・弱衝突耐性<br>(ハッシュ値から元のデータを類推するのが難しい)
* ・強衝突耐性<br>(同一ハッシュ値を持つ入力データを見つけるのが難しい)
</script>

<script layout type="text/x-markdown">
#### ハッシュ関数の利用用途
* ・チェックサム, フィンガープリント
* ・Git log
</script>

<script layout type="text/x-markdown">
#### セキュリティの観点
* ハッシュ値の衝突の起きにくさ = アルゴリズムの良さ
* 衝突が起こせるため、セキュリティ用途では非推奨になってるハッシュ関数もある
* e.g.) MD5, SHA-1
</script>

<script layout type="text/x-markdown">
### 4.2.2 共通鍵暗号と公開鍵暗号とデジタル署名
</script>

<script layout type="text/x-markdown">
* 暗号のアルゴリズムで重要なのは、アルゴリズムが公開されていても安全に通信できること
* TLSで使われるものには、「共通鍵方式」と「公開鍵方式」の2種類がある
* デジタル署名は公開鍵方式の応用例
* ・`秘密鍵: 南京錠`, `公開鍵: 南京錠の鍵` になる (公開鍵方式とは逆の役割)
</script>

<script layout type="text/x-markdown">
### 4.2.3 鍵交換
</script>

<script layout type="text/x-markdown">
* クライアントとサーバー間で鍵を交換する
* 方法としては、前述の暗号化を使うこともあるし、専用のアルゴリズムを使うこともある
* 専用のアルゴリズムには、`DH(Diffie Hellman)鍵交換`がある
* Logjam攻撃を受けないように、DH鍵交換で使用するbit数は大きくする
* ・512bit以下はまずい [Logjam Attackについてまとめてみた - piyolog](http://d.hatena.ne.jp/Kango/20150521/1432219012)
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script layout type="text/x-markdown">
###
</script>

<script layout type="text/x-markdown">
*
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
<script src="./dist/talkie.min.js"></script>
<script>Talkie();</script>
</body>
</html>
